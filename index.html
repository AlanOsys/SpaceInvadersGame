<!DOCTYPE html>
<head>
<title>Space Invaders</title>

<style type="text/css">
body {
    background-color: rgb(87, 87, 87);
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: "Poppins", sans-serif;
    outline: none;
    -webkit-user-select: none; /* Safari */
  -ms-user-select: none; /* IE 10 and IE 11 */
  user-select: none; /* Standard syntax */
}
#container{
    width: 300px;
    height: 300px;
    background-color: #16161d;
    left: 0px;
    top: 0xp;
    position: absolute;
}
.Entity{
    background-color: aliceblue;
    width: 40px;
    height: 40px;
    position: absolute;
    left: 0px;
    top: 0px;
}
.ProjectileEntity{
    width: 20px;
    height: 20px;
    position: absolute;
    background-color: aquamarine;
    left: 0px;
    top: 0px;
    animation: spin 3s linear infinite;

}
.ProjectileEntity.animate {
  animation: spin 30s linear infinite;
}
@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  1.66%,
  3.33% {
    transform: rotate(12deg);
  }
  4.99%,
  6.66% {
    transform: rotate(24deg);
  }
  8.32%,
  9.99% {
    transform: rotate(36deg);
  }
  11.65%,
  13.32% {
    transform: rotate(48deg);
  }
  14.98%,
  16.65% {
    transform: rotate(60deg);
  }
  18.31%,
  19.98% {
    transform: rotate(72deg);
  }
  21.65%,
  23.31% {
    transform: rotate(84deg);
  }
  24.98%,
  26.65% {
    transform: rotate(96deg);
  }
  28.31%,
  29.98% {
    transform: rotate(108deg);
  }
  31.65%,
  33.33% {
    transform: rotate(120deg);
  }
  34.98%,
  36.65% {
    transform: rotate(132deg);
  }
  38.33%,
  39.98% {
    transform: rotate(144deg);
  }
  41.65%,
  43.33% {
    transform: rotate(156deg);
  }
  44.98%,
  46.65% {
    transform: rotate(168deg);
  }
  48.33%,
  50% {
    transform: rotate(180deg);
  }
  51.65%,
  53.33% {
    transform: rotate(192deg);
  }
  54.99%,
  56.65% {
    transform: rotate(204deg);
  }
  58.33%,
  59.99% {
    transform: rotate(216deg);
  }
  61.65%,
  63.33% {
    transform: rotate(228deg);
  }
  64.99%,
  66.66% {
    transform: rotate(240deg);
  }
  68.33%,
  69.99% {
    transform: rotate(252deg);
  }
  71.66%, 73.33% {
    transform: rotate(264deg);
  }
  74.99%,
  76.66% {
    transform: rotate(276deg);
  }
  78.33%,
  79.99% {
    transform: rotate(288deg);
  }
  81.66%,
  83.33% {
    transform: rotate(300deg);
  }
  84.99%,
  86.66% {
    transform: rotate(312deg);
  }
  88.33%,
  89.99% {
    transform: rotate(324deg);
  }
  91.66%,
  93.33% {
    transform: rotate(336deg);
  }
  94.99%,
  96.66% {
    transform: rotate(348deg);
  }
  98.33%,
  100% {
    transform: rotate(360deg);
  }
}
</style>

</head>

<body>
    <div id="container"></div>
<script>
    container = document.getElementById("container")
    class Invader{
        constructor(name) {
            this.name = name
            this.speed = 1
            this.direction = 'left'
            this.maxSpeed = 2
            this.attackSpeed = 1
        }
        instantiate(){
            var Entity = document.createElement("div")
            this.Entity = Entity

            this.Entity.innerHTML = 40-this.attackSpeed*5
            Entity.id = this.name
            Entity.className = "Entity"
            container.appendChild(Entity)
        }
    }
    class Projectile{
        constructor(invader,EnemyInvader){
            this.invader = invader
            this.EnemyInvader = EnemyInvader
            
        }
        instantiate(){
            var ProjectileEntity = document.createElement("div")
            this.ProjectileEntity = ProjectileEntity
            ProjectileEntity.className = "ProjectileEntity"
            ProjectileEntity.style.top = this.invader.Entity.style.top
            ProjectileEntity.style.left = this.invader.Entity.style.left
            ProjectileEntity.style.width = 20-this.invader.attackSpeed*3+"px"
            if(this.invader.name == "Shotgun"){
                ProjectileEntity.style.width = "70px"
            }
            if(parseInt(ProjectileEntity.style.top)>100){
                this.direction = 'down'
            }else{
                this.direction = 'up'
            }
            
            container.appendChild(ProjectileEntity)
            //console.log("pp")
        }
    }
    function Initialise(){
        inv = new Invader("Shotgun")
        
        opp = new Invader("Speedster")
        

        //Speedster = ms5
        opp.maxSpeed = 1
        opp.instantiate()
        opp.Entity.style.backgroundColor = "yellow"

        //Shooter = as4
        inv.attackSpeed = 1
        inv.instantiate()
        inv.Entity.style.backgroundColor = "green"
        

        opp.Entity.style.left = "130px"
        opp.Entity.style.top = "260px"
        
        inv.Entity.style.left = "130px"
        inv.Entity.style.top = "1px"


        InvaderArray = [inv,opp]
        Projectiles = []
    }
    
Initialise()
Finished = false
const interval = setInterval(function() {
    if(!Finished){
    for(let i = 0;i<InvaderArray.length;i++){
        if(InvaderArray[i].direction == 'left'){
            if(parseInt(InvaderArray[i].Entity.style.left) <= 0){
                InvaderArray[i].direction = 'right'
                InvaderArray[i].speed = (Math.random()*InvaderArray[i].maxSpeed)+1
            }else{
                InvaderArray[i].Entity.style.left = parseInt(InvaderArray[i].Entity.style.left)-InvaderArray[i].speed + "px"
            }
        }else{
            if(parseInt(InvaderArray[i].Entity.style.left) >= 260){
                InvaderArray[i].direction = 'left'
                InvaderArray[i].speed = (Math.random()*InvaderArray[i].maxSpeed)+1
            }else{
                InvaderArray[i].Entity.style.left = parseInt(InvaderArray[i].Entity.style.left)+InvaderArray[i].speed + "px"
            }
        }
        ShootChance = (Math.random()*300)//InvaderArray[i].Entity.attackSpeed
        if(ShootChance <= InvaderArray[i].attackSpeed){
            if(i == 0){
                EnemyInvader = InvaderArray[1]
            }else{
                EnemyInvader = InvaderArray[0]
            }
            newProj = new Projectile(InvaderArray[i],EnemyInvader)
            Projectiles.push(newProj)
            
            newProj.instantiate()
            //newProj.ProjectileEntity.style.width = 20-InvaderArray[i].attackSpeed*3+"px"
            newProj.ProjectileEntity.style.backgroundColor = InvaderArray[i].Entity.style.backgroundColor
        }
    }
    projectilesToDestroy = []
    for(let j = 0;j<Projectiles.length;j++){
        //console.log(Projectiles[j].ProjectileEntity.style.top)
        if(Projectiles[j].ProjectileEntity){
            if(Projectiles[j].direction == 'down'){
                Projectiles[j].ProjectileEntity.style.top = parseInt(Projectiles[j].ProjectileEntity.style.top)-1+"px"
            }else{
                Projectiles[j].ProjectileEntity.style.top = (parseInt(Projectiles[j].ProjectileEntity.style.top)+1)+"px"
            }
            //console.log(newProj.ProjectileEntity.getBoundingClientRect(),
             //           EnemyInvader.Entity.getBoundingClientRect())
            //console.log(overlapping(newProj.ProjectileEntity,EnemyInvader.Entity))
            if(overlapping(Projectiles[j].ProjectileEntity,Projectiles[j].EnemyInvader.Entity)){
                Projectiles[j].EnemyInvader.Entity.innerHTML = parseInt(Projectiles[j].EnemyInvader.Entity.innerHTML)-1
                Projectiles[j].ProjectileEntity.remove()
                projectilesToDestroy.push(j)
                if(Projectiles[j].EnemyInvader.Entity.innerHTML == "0"){
                    Projectiles[j].EnemyInvader.Entity.remove()
                    Finished = true
                }
                
            }
        }
        if (parseInt(Projectiles[j].ProjectileEntity.style.top)<0 || 
        parseInt(Projectiles[j].ProjectileEntity.style.top)>=280){
            Projectiles[j].ProjectileEntity.remove()
            projectilesToDestroy.push(j)
        }
    }
    while(projectilesToDestroy.length>0){
        Projectiles.splice(projectilesToDestroy[0],1)
        projectilesToDestroy.shift()
    }
}
}, 10);

function overlapping(obj1,obj2){
    rect1 = obj1.getBoundingClientRect()
    rect2 = obj2.getBoundingClientRect()
    var overlap = !(rect1.right < rect2.left || 
                rect1.left > rect2.right || 
                rect1.bottom < rect2.top || 
                rect1.top > rect2.bottom)
    return overlap
}
</script>

</body>

